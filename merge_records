def merge_records(cursor, catalog, schema, table, df, batch_size=100):

    total = len(df)
    if total == 0:
        logging.warning("No lineage rows to merge.")
        return

    cols = [
        "parent_model", "parent_project", "parent_schema",
        "child_model", "child_project", "child_schema",
        "relation_type", "parent_fqn", "child_fqn", "timestamp"
    ]

    for start in range(0, total, batch_size):
        batch = df.iloc[start:start+batch_size]

        rows = []
        for _, row in batch.iterrows():
            vals = [str(row[c]).replace("'", "''") for c in cols]
            rows.append(f"ROW('{vals[0]}','{vals[1]}','{vals[2]}','{vals[3]}','{vals[4]}','{vals[5]}','{vals[6]}','{vals[7]}','{vals[8]}','{vals[9]}')")

        values_sql = ",\n".join(rows)

        merge_sql = f"""
        MERGE INTO {catalog}.{schema}.{table} t
        USING (
            SELECT * FROM (
                VALUES
                {values_sql}
            ) AS v(
                parent_model, parent_project, parent_schema,
                child_model, child_project, child_schema,
                relation_type, parent_fqn, child_fqn, timestamp
            )
        ) s
        ON (
            t.parent_model = s.parent_model AND
            t.parent_project = s.parent_project AND
            t.child_model = s.child_model AND
            t.child_project = s.child_project AND
            t.relation_type = s.relation_type
        )
        WHEN MATCHED THEN UPDATE SET
            timestamp = s.timestamp
        WHEN NOT MATCHED THEN INSERT VALUES (
            s.parent_model, s.parent_project, s.parent_schema,
            s.child_model, s.child_project, s.child_schema,
            s.relation_type, s.parent_fqn, s.child_fqn, s.timestamp
        )
        """

        cursor.execute(merge_sql)
        logging.info(f"Merged rows {start+1}â€“{min(start+batch_size, total)}")
