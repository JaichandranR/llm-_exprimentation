import psycopg2
import requests
import numpy as np
from scipy.spatial.distance import cosine
import json
from ecdpawssession.session_builder import SessionBuilder

# Step 1: Postgres connection setup
USERNAME = ''  # Leave blank for IAM authentication
DOMAIN = 'naeast'  # ENTER DOMAIN
ROLE_ARN = 'arn:aws:iam::ROLE/90177-aurora-app-admin'  # ENTER ROLE ARN
ENDPOINT = 'proxy-postgres-nlb.elb.us-east-1.amazonaws.com'  # ENTER DB NLB PROXY
CLUSTER = 'aurora-cluster.cluster-c1wayscsgqcd.us-east-1.rds.amazonaws.com'  # ENTER PG Cluster
PORT = '6160'  # ENTER PORT
USER = 'llmdbAuroraAppAdmin'  # ENTER USER
REGION = 'us-east-1'  # ENTER REGION
DBNAME = 'llmdb'  # ENTER DB

# Generate RDS token for authentication
session = SessionBuilder.cli(
    role_arn=ROLE_ARN, 
    region=REGION, 
    username=USERNAME, 
    domain=DOMAIN, 
    store_password=True
).with_auto_renew().build()

client = session.client('rds')
token = client.generate_db_auth_token(
    DBHostname=CLUSTER, 
    Port=PORT, 
    DBUsername=USER, 
    Region=REGION
)

# Establish database connection
def get_postgres_connection():
    try:
        conn = psycopg2.connect(
            host=ENDPOINT,
            user=USER,
            password=token,
            port=PORT,
            database=DBNAME
        )
        print("Database connection successful.")
        return conn
    except Exception as e:
        print(f"Database connection failed due to {e}")
        raise

# Step 2: Hosted API setup
API_URL = "http://your-eks-hosted-url"  # Replace with the actual URL of your hosted API
API_KEY = "3g7h1e9a5b0d2f81a4c6"  # Replace with your actual API key

# Get query embedding from API
def get_query_embedding(text):
    headers = {
        "Content-Type": "application/json",
        "x-api-key": API_KEY
    }
    
    payload = {
        "model": "bge-large-en-v1.5",
        "text": text
    }

    response = requests.post(API_URL, headers=headers, json=payload)
    if response.status_code == 200:
        result = response.json()
        embedding = result.get("embedding")
        if embedding is None or not isinstance(embedding, list):
            raise ValueError("Invalid embedding received from API.")
        embedding = np.array(embedding, dtype=float)  # Convert to numpy array
        norm = np.linalg.norm(embedding)
        if norm == 0:
            print(f"Query embedding: {embedding}")
            raise ValueError("Query embedding has zero magnitude.")
        return embedding
    else:
        print(f"API response: {response.text}")
        raise RuntimeError(f"API call failed with status code {response.status_code}: {response.text}")

# Fetch embeddings from PostgreSQL
def fetch_embeddings_from_db():
    conn = get_postgres_connection()
    cursor = conn.cursor()

    try:
        cursor.execute("SELECT control_id, chunk_id, source, embedding FROM application.mitre_embeddings;")
        rows = cursor.fetchall()

        # Convert to a list of dictionaries
        embeddings = []
        for row in rows:
            control_id, chunk_id, source, embedding_str = row
            try:
                embedding = json.loads(embedding_str)  # Deserialize JSON string to list
                embedding = np.array(embedding, dtype=float)  # Convert to numpy array
                norm = np.linalg.norm(embedding)
                if norm == 0:
                    print(f"Skipping embedding with zero magnitude for control_id {control_id}, chunk_id {chunk_id}.")
                    continue
            except (json.JSONDecodeError, ValueError) as e:
                print(f"Error decoding embedding for control_id {control_id}, chunk_id {chunk_id}: {e}")
                continue

            embeddings.append({
                "control_id": control_id,
                "chunk_id": chunk_id,
                "source": source,
                "embedding": embedding
            })
        return embeddings
    finally:
        cursor.close()
        conn.close()

# Perform similarity search
def similarity_search(query_text, top_k=5):
    # Get query embedding
    query_embedding = get_query_embedding(query_text)

    # Fetch embeddings from the database
    embeddings = fetch_embeddings_from_db()

    # Calculate cosine similarity and sort results
    results = []
    for record in embeddings:
        try:
            similarity = 1 - cosine(query_embedding, record["embedding"])
            results.append({
                "control_id": record["control_id"],
                "chunk_id": record["chunk_id"],
                "source": record["source"],
                "similarity": similarity
            })
        except ValueError as e:
            print(f"Error calculating similarity for control_id {record['control_id']}: {e}")
            continue

    # Sort by similarity in descending order
    results = sorted(results, key=lambda x: x["similarity"], reverse=True)

    # Return top-k results
    return results[:top_k]

# Example usage
if __name__ == "__main__":
    query = "Describe the mitigation technique for preventing phishing attacks."
    top_results = similarity_search(query, top_k=5)
    
    print("Top results:")
    for result in top_results:
        print(f"Control ID: {result['control_id']}, Chunk ID: {result['chunk_id']}, Source: {result['source']}, Similarity: {result['similarity']:.4f}")
