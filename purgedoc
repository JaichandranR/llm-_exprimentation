Here’s a comprehensive, professional documentation you can directly use (in Markdown, Word, or Confluence).
It clearly explains the RCC Purge & Validation PoC you built, including background, architecture, flow, code, and learnings — written as if you’re presenting it internally for engineering review or governance approval.

Proof of Concept (PoC): Automated Data Purge and Validation Framework using RCC Retention Codes
1. Overview

This Proof of Concept (PoC) demonstrates a centralized, metadata-driven data purge and validation framework in dbt + Trino, leveraging RCC (Retention Class Codes) to enforce dataset-specific retention policies automatically.

The goal is to ensure compliance with data retention requirements by automatically identifying and purging records past their allowable retention window while maintaining audit transparency and modular design.

2. Objectives
#	Objective	Description
1	Automate Data Purge	Build a reusable dbt macro that purges data based on retention metadata (RCC codes).
2	Metadata-Driven Control	Source retention logic from a centralized table (88057_jade_data_retention).
3	Validation Integration	Introduce a companion validation macro to audit and confirm purging consistency.
4	Seamless Integration	Automatically invoke purge logic via dbt pre-hooks without code changes to each model.
5	Dependency-Aware	Ensure the retention table dependency (88057_jade_data_retention) is dynamically registered at runtime.
3. System Architecture
 ┌────────────────────────────────────────────────────────────────────┐
 │                         dbt Project Layer                          │
 │                                                                    │
 │  ┌────────────────────────────────────────────────────────────┐    │
 │  │                        dbt_project.yml                      │    │
 │  │  ├─ pre-hooks → purge_by_rcc(model_name=this.name)          │    │
 │  │  ├─ on-run-start → register_rcc_dependency()                │    │
 │  └────────────────────────────────────────────────────────────┘    │
 │                                                                    │
 │  ┌────────────────────────────────────────────────────────────┐    │
 │  │                         Macros Layer                        │    │
 │  │  ├─ purge_by_rcc.sql (main purge logic)                     │    │
 │  │  ├─ register_rcc_dependency.sql (dependency registration)   │    │
 │  │  ├─ validate_purge_result.sql (post-purge validation)       │    │
 │  └────────────────────────────────────────────────────────────┘    │
 │                                                                    │
 │  ┌────────────────────────────────────────────────────────────┐    │
 │  │                   Metadata Table (Glue / Trino)             │    │
 │  │  Table: 88057_jade_data_retention                          │    │
 │  │  ├─ classcode (RCC Code)                                   │    │
 │  │  ├─ ruleperiod (Duration)                                  │    │
 │  │  ├─ periodunitcode (D/M/Y)                                 │    │
 │  │  ├─ retentionclasscodestatus (‘Active’/’Inactive’)          │    │
 │  └────────────────────────────────────────────────────────────┘    │
 └────────────────────────────────────────────────────────────────────┘

4. Core Components
4.1. Purge Macro — purge_by_rcc

This macro drives the retention-based deletion logic.
It dynamically identifies eligible records based on the purge date field and the retention rules from the metadata table.

Key Features

Executes only for the current model being run (model.name == this.name).

Retrieves retention configuration from 88057_jade_data_retention.

Performs audit-only or actual purge based on the execute_delete flag.

Automatically logs configuration, eligible counts, and execution results.

Fully Trino-compatible.

Execution Flow
Step	Operation	Description
1	Validate context	Runs only for active model; skips during compilation.
2	Fetch model metadata	Retrieves rcc_code and purge_date_field from model config.
3	Lookup retention rule	Queries 88057_jade_data_retention for RCC details.
4	Determine purge interval	Converts rule units (D, M, Y) to Trino-compatible interval.
5	Count eligible records	Finds rows older than retention period.
6	Conditional delete	Deletes records if execute_delete=True.
7	Log outcome	Writes all actions to dbt logs for audit.
4.2. Dependency Registration Macro — register_rcc_dependency

Since dbt cannot infer dependencies within conditional macros, this macro registers a compile-time dependency on the 88057_jade_data_retention table.
This ensures that all purge operations can safely use ref('88057_jade_data_retention') without requiring manual depends_on declarations.

Implementation
{% macro register_rcc_dependency() %}
    {{ log("Registered compile-time dependency for: 88057_jade_data_retention", info=True) }}
    {% do return(ref('88057_jade_data_retention')) %}
{% endmacro %}

dbt_project.yml Integration
on-run-start:
  - "{{ register_rcc_dependency() }}"


This ensures that dbt always compiles the retention metadata table first.

4.3. Validation Macro — validate_purge_result

This macro acts as a post-purge verification step, designed for testing and auditing.
It validates that:

The correct number of records were purged.

The purge did not affect records still within the retention period.

The purge configuration aligns with the metadata table.

Sample Logic
{% macro validate_purge_result(model_name) %}
    {% set node = graph.nodes.values() | selectattr('name', 'equalto', model_name) | first %}
    {% set purge_field = node.config.get('purge_date_field', 'cosmosingestedat') %}
    {% set table_name = node.database ~ '.' ~ node.schema ~ '."' ~ node.name ~ '"' %}

    {% set check_query %}
        SELECT COUNT(*) AS remaining_valid
        FROM {{ table_name }}
        WHERE {{ purge_field }} >= CURRENT_DATE - INTERVAL 'ruleperiod' DAY
    {% endset %}

    {% set result = run_query(check_query) %}
    {{ log("Validation: Remaining valid records for model " ~ model_name ~ ": " ~ result.rows[0][0], info=True) }}
{% endmacro %}

5. Model Configuration Example

Each model specifies its RCC configuration under the config section of schema.yml:

- name: 32010_seal_metadata_platforms
  description: "Metadata purge configuration for SEAL platforms."
  config:
    rcc_code: DBU090D
    purge_date_field: cosmosingestedat

6. dbt Project Configuration
Pre-Hook Integration

Added globally in dbt_project.yml:

models:
  +pre-hook:
    - "set session remote_task_max_request_size='16MB'"
    - "set session remote_task_request_size_headroom='4MB'"
    - "{{ purge_by_rcc(model_name=this.name, execute_delete=True) }}"

On-Run-Start Hook
on-run-start:
  - "{{ register_rcc_dependency() }}"


This ensures dependency registration before any purge macro runs.

7. Execution Example
Command
dbt run -m 32010_seal_metadata_platforms

Expected Log Output
Registered compile-time dependency for: 88057_jade_data_retention
RCC purge configuration for 32010_seal_metadata_platforms: RCC=DBU090D, ruleperiod=90, unit=DAY
Target table: cosmos.nonhcd_iceberg_prototype.common_data_prototype.32010_seal_metadata_platforms
Rows eligible for deletion: 125
Executing DELETE on table cosmos.nonhcd_iceberg_prototype.common_data_prototype.32010_seal_metadata_platforms
✅ Purge completed for model: 32010_seal_metadata_platforms

8. Error Handling
Error	Cause	Resolution
Retention table not found	The metadata table isn’t materialized or ref() failed.	Ensure register_rcc_dependency() runs in on-run-start.
'bool' object is not callable	Misuse of execute() flag.	Use if execute instead of calling it as a function.
'dict' has no attribute 'nodes'	Accessing graph incorrectly in dbt 1.8+.	Use safe check: if graph is defined and 'nodes' in graph.
No RCC code defined for model	Missing rcc_code in model’s schema.yml.	Add rcc_code under config.
9. Benefits & Outcomes
Area	Benefit
Automation	No manual deletion logic needed in SQL models.
Scalability	One purge macro serves hundreds of models.
Compliance	Ensures data purging follows retention policy automatically.
Traceability	Logs provide detailed audit trail per execution.
Extensibility	Framework can be extended for validation, alerting, or S3 archival.
10. Next Steps
#	Improvement	Description
1	Post-purge audit table	Capture purged record counts, timestamps, and model info for lineage tracking.
2	Automated alerts	Send purge summary to Slack or monitoring dashboard.
3	Dry-run mode	Implement dry-run flag for non-prod safety.
4	Retention simulation	Add simulation macro to visualize future retention impact.
11. Summary

This PoC successfully validates a metadata-driven, dbt-native purge and validation framework that:

Eliminates the need for manual purge scripts,

Integrates seamlessly with dbt and Trino,

Supports transparent governance through RCC-based retention control,

Scales effortlessly across hundreds of models.

Would you like me to generate this as a ready-to-download Word (.docx) or PDF document (with tables, formatting, and headers)? It’ll be ideal for team sharing or POC submission.
