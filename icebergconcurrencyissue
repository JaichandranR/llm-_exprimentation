‚úÖ What Happens If You Run dbt run (Trino) + Delete Records (Glue Spark) at the Same Time?

Iceberg supports multi-writer concurrency, but only when both engines follow Iceberg‚Äôs commit protocol correctly.
However, issues arise if:

1. Two writers update the same snapshot concurrently

Trino (dbt) produces a new Iceberg snapshot when it inserts/merges.

Glue Spark produces a new snapshot when it deletes.

If these two commits happen at the exact same time, only one will succeed and the other will fail with:

CommitFailedException

Validation failed

ConcurrentModificationException

Cannot commit the snapshot because base snapshot has changed

This is expected behavior in Iceberg to prevent corruption.

Trino does not automatically retry commits, so your dbt run may fail.

‚ùó Common Failure Scenarios
Scenario A: dbt run inserting/merging while Glue deletes

Glue Spark deletion writes a new manifest & snapshot.

dbt‚Äôs write is based on the previous snapshot ‚Üí its commit fails.

Result: dbt run fails, Glue Spark succeeds.

Scenario B: Glue deletes while Trino reads

If dbt is reading while Spark deletes, no correctness issue ‚Äî Iceberg is snapshot-isolated:

‚úî dbt sees the old snapshot
‚úî Spark writes a new snapshot
‚úî No corruption

This is safe.

Scenario C: dbt write + Glue rewrite (compaction) at same time

If Glue Spark is compacting or rewriting files while dbt writes, you may get:

snapshot conflict

commit validation failure

‚≠ê WHEN IS IT 100% SAFE?

Only READs can run in parallel.
Writes cannot safely run in parallel unless you implement one of the coordination techniques below.

üü© Why Iceberg Prevents Corruption

Iceberg uses an optimistic concurrency model.
Every writer validates:

table metadata file hasn't changed

base snapshot is still the same

If not, the commit is rejected.
This prevents:

partial updates

lost deletes

overwriting another writer‚Äôs changes
