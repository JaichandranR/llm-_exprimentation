GLOBAL DBT GOVERNANCE PLATFORM
Three Core Components

Global Metadata Collector
(extract all manifest.json files + Iceberg metadata)

Global Lineage Graph Builder
(cross-project DAG + referential integrity graph)

Global RCC + DRD Policy Engine
(governance rules, purge safety, warnings, enforcement)

üß© High-Level Architecture Diagram
+------------------+       +----------------------+      +-----------------------+
|  Team A dbt proj |       |  Team B dbt proj     |      |  Team C dbt proj      |
|  manifest.json   |       |  manifest.json       |      |  manifest.json        |
+---------+--------+       +----------+-----------+      +-----------+-----------+
          |                           |                              |
          +----------- Upload all manifest.json to central S3 bucket |
                                  (triggered via CI/CD or manual)    |
------------------------------------------------------------------------
                                |
                                v
                   +---------------------------+
                   | GLOBAL METADATA COLLECTOR |
                   |  (Kestra or Glue Python)  |
                   +-------------+-------------+
                                 |
                     Writes unified metadata ‚Üí
                                 |
       +-------------------------+-----------------------------+
       |                                                           |
       v                                                           v
+-----------------------+                            +------------------------+
| GLOBAL MODEL REGISTRY |                            | GLOBAL DEPENDENCY EDGES|
| (Iceberg Table)       |                            | (Iceberg Table)         |
+-----------------------+                            +------------------------+
       |                                                           |
       +-------------------------+---------------------------------+
                                 |
                                 v
                   +-----------------------------+
                   | GLOBAL LINEAGE GRAPH ENGINE |
                   | (NetworkX / Neptune / Neo4j)|
                   +--------------+--------------+
                                  |
                  Provides DAG for ‚Üí RCC + DRD Policy Engine
                                  |
                                  v
                 +----------------------------------------+
                 |  GLOBAL RCC / DRD GOVERNANCE LAYER     |
                 |  - purge safety                         |
                 |  - lineage integrity                    |
                 |  - unpartitioned table alerts           |
                 |  - dependency-aware retention rules     |
                 |  - shared table tracking                |
                 +----------------------------------------+

üß± COMPONENT 1 ‚Äî GLOBAL METADATA COLLECTOR

The collector gathers model metadata and Iceberg metadata from all teams.

Sources

manifest.json from every dbt project

Iceberg catalog metadata (via Trino query or Glue API)

Collector Workflow (Python)
Step 1 ‚Äî Read all manifest.json files from S3
s3://dbt-artifacts/<team>/manifest.json

Step 2 ‚Äî For each model, extract:

model_name

schema

database

alias (table name)

full relation (database.schema.table)

project name

tags (incl. RCC code)

description

depends_on.nodes[]

resource_type

package_name

unique_key (if incremental)

materialization

file path

config partition_by (if any)

Step 3 ‚Äî Also fetch Iceberg metadata:

partition_fields

snapshot lineage

file count

record count

last_modified timestamp

Step 4 ‚Äî Insert into GLOBAL MODEL REGISTRY table.
üìò Schema: GLOBAL_MODEL_REGISTRY (Iceberg Table)
Column	Type	Description
model_id	string	unique id from manifest
project	string	dbt project name
model_name	string	model name
table_name	string	Iceberg table name (infer from alias)
database	string	catalog/db
schema	string	schema name
fully_qualified_name	string	db.schema.table
materialization	string	table/view/incremental/ext
unique_key	array<string>	incremental key
rcc_code	string	retention code
retention_days	int	from RCC metadata
has_partition	boolean	derived from Iceberg metadata
partition_columns	array<string>	partition columns
iceberg_records	bigint	number of rows
iceberg_files	bigint	num data files
last_snapshot_id	string	latest snapshot
last_updated_at	timestamp	snapshot commit time
model_owner	string	team/owner
is_shared	boolean	used by other projects
is_purge_eligible	boolean	dynamic rule
risk_level	string	low/medium/high/very_high
file_path	string	model sql file

This is your system of record.

üß© COMPONENT 2 ‚Äî GLOBAL DEPENDENCY EDGES TABLE
Schema: GLOBAL_DEPENDENCY_EDGES
Column	Type	Description
parent_model	string	upstream model
child_model	string	downstream model
parent_project	string	project name
child_project	string	project name
relation_type	string	ref, source, seed, external
parent_table	string	database.schema.table
child_table	string	database.schema.table

This table allows direction-of-flow evaluation like:

COSMOS.model_a -> TECHGRC.model_b -> COMMON_DATA.model_c

üß† COMPONENT 3 ‚Äî GLOBAL LINEAGE GRAPH ENGINE

Using NetworkX (simple) or AWS Neptune (enterprise).

Graph Nodes = models
Graph Edges = dependencies

Graph Attributes added:

retention_days

partitioning

owner project

rcc_code

unique keys

number_of_dependents

This enables:

1. Impact Analysis

‚ÄúWhat breaks if I purge model A?‚Äù

2. Referential Integrity Simulation

‚ÄúCan we safely delete rows from table X?‚Äù

3. Shared Model Visibility

Teams can visualize who uses their model.

4. Cycle Detection

Forbidden cross-model loops.

5. Partition Risk Analysis

Detect tables without partitions that are referenced downstream.

üõ° COMPONENT 4 ‚Äî GLOBAL RCC + DRD POLICY ENGINE

This is where you enforce the rules.

‚úî Rule 1 ‚Äî Unpartitioned Tables
if has_partition == false:
    is_purge_eligible = false
    risk_level = 'very_high'

‚úî Rule 2 ‚Äî Cross-Team Dependencies
if exists downstream models from another project:
    protect upstream model from purge unless retention alignment holds

‚úî Rule 3 ‚Äî Retention Alignment
if parent.retention_days < child.retention_days:
    mark violation

‚úî Rule 4 ‚Äî Active Partition Protection
if table partition == current or recently updated:
    skip purge

‚úî Rule 5 ‚Äî Shared Tables Must Not Be Purged Automatically
if model.is_shared == true:
    require explicit override

üß† How Everything Fits Together

Manifest + Iceberg metadata ‚Üí stored into Iceberg registry tables

Dependency edges ‚Üí stored into edges table

Lineage engine builds cross-team DAG

Policy engine evaluates:

retention misalignment

partitioning risk

dependency issues

purge eligibility

DRD engine purges only ‚Äúgreen-flag‚Äù tables/partitions

üü¶ Putting It All Together ‚Äî Sample Output of Governance Dashboard
Model: cosmos__customers

Partitioned: YES

Partition column: ingestion_date

Retention: 30 days

Upstream: raw.customers_api

Downstream: techgrc__transactions

Shared: YES

Risk Level: MEDIUM

Purge Eligible: NO (downstream model has 90-day retention)

Model: common_data__clickstream

Partitioned: NO

Retention: 30 days

Shared: YES

Risk Level: VERY HIGH

Purge Eligible: NO

Model: techgrc__vpc_flow_logs

Partitioned: YES

Size: 4 TB

Retention: RCC = 7 days

Risk Level: LOW

Purge Eligible: YES

üüß NEXT STEPS (I can generate these for you)

If you want, I can produce:

A. Full Python script

Reads all manifests

Reads Iceberg metadata

Writes global registry + edges tables

B. SQL schema definitions

For Iceberg tables

With correct types

C. Governance rules logic

Partition detection

Safe purge flag

Downstream dependency checks

Retention alignment validation

D. Kestra workflow design

Trigger on manifest uploads

Extract metadata

Build graph

Run RCC validation

Generate email / Slack alerts

E. Architecture diagram (PNG)

Clean, executive-level diagram

Just tell me which piece you want next, and I will generate it.
