import sys
import types
import unittest
from unittest import mock

# Step 1: Fake CLI arguments required by getResolvedOptions
sys.argv = [
    "common_data_sync.py",
    "--source_db", "dummy_src",
    "--target_db", "dummy_target",
    "--region", "us-east-1",
    "--s3_bucket", "dummy-bucket",
    "--s3_prefix", "dummy-prefix"
]

# Step 2: Mock awsglue and pyspark modules
awsglue = types.ModuleType("awsglue")
awsglue_context = types.ModuleType("awsglue.context")
awsglue_utils = types.ModuleType("awsglue.utils")
pyspark_context = types.ModuleType("pyspark.context")

awsglue_context.GlueContext = mock.MagicMock()
awsglue_utils.getResolvedOptions = mock.MagicMock(return_value={
    "source_db": "dummy_src",
    "target_db": "dummy_target",
    "region": "us-east-1",
    "s3_bucket": "dummy-bucket",
    "s3_prefix": "dummy-prefix"
})
pyspark_context.SparkContext = mock.MagicMock()

# Inject into sys.modules
sys.modules["awsglue"] = awsglue
sys.modules["awsglue.context"] = awsglue_context
sys.modules["awsglue.utils"] = awsglue_utils
sys.modules["pyspark"] = types.SimpleNamespace(SparkContext=mock.MagicMock())
sys.modules["pyspark.context"] = pyspark_context

# Step 3: Mock boto3 client before importing the real code
mock_glue_client = mock.MagicMock()
mock_paginator = mock.MagicMock()
mock_paginator.paginate.return_value = [
    {
        "TableList": [
            {
                'Name': 'test_table',
                'StorageDescriptor': {
                    'Location': 's3://mock-location/',
                    'Columns': [],
                    'SerdeInfo': {}
                },
                'PartitionKeys': [],
                'Parameters': {
                    'classification': 'json',
                    'table_type': 'OTHER',
                    'metadata_location': 's3://mock-location/test_table/metadata'
                }
            }
        ]
    }
]
mock_glue_client.get_paginator.return_value = mock_paginator

with mock.patch("src.main.python.common_data_sync.boto3.client", return_value=mock_glue_client):
    from src.main.python import common_data_sync

    class TestCommonDataSync(unittest.TestCase):

        def test_copy_tables_success(self):
            with mock.patch("src.main.python.common_data_sync.create_or_update_table"), \
                 mock.patch("src.main.python.common_data_sync.sync_table_partitions"), \
                 mock.patch("src.main.python.common_data_sync.delete_orphan_tables"):

                # Reset summary table before each test
                common_data_sync.summary_table['processed_tables'] = 0
                common_data_sync.summary_table['failed_tables'] = 0
                common_data_sync.summary_table['deleted_tables'] = 0
                common_data_sync.summary_table['errors'] = []

                common_data_sync.copy_tables()

                self.assertEqual(common_data_sync.summary_table['processed_tables'], 1)
                self.assertEqual(common_data_sync.summary_table['failed_tables'], 0)
                self.assertEqual(common_data_sync.summary_table['deleted_tables'], 0)
                self.assertEqual(common_data_sync.summary_table['errors'], [])

if __name__ == "__main__":
    unittest.main()
