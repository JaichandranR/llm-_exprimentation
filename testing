import json
import os
import re
from pathlib import Path
from collections import defaultdict

MANIFEST_DIR = "manifests"   # folder containing manifest_*.json files


# ----------------------------
# 1. Load ALL manifest files
# ----------------------------
def load_manifests():
    manifests = []
    for file in Path(MANIFEST_DIR).glob("manifest_*.json"):
        try:
            with open(file, "r") as f:
                manifests.append(json.load(f))
        except Exception as e:
            print(f"[ERROR] Failed to load {file}: {e}")
    return manifests


# --------------------------------------
# 2. Extract domain/project from node_id
# --------------------------------------
def extract_project_from_node(node_id):
    """
    Example:
      model.cosmos.87674_verum_asset_details â†’ cosmos
      model.resiliency.db_inventory â†’ resiliency
      model.cyberops.xxxxx â†’ cyberops
    """
    parts = node_id.split(".")
    if len(parts) >= 3:
        return parts[1]        # <--- project name from manifest
    return "unknown"


# -------------------------------------------
# 3. Extract models for global registry
# -------------------------------------------
def build_global_model_registry(manifests):
    """
    Registry = { model_name: { project, schema, fqn, raw_code } }
    """
    registry = {}

    for man in manifests:
        nodes = man.get("nodes", {})
        for node_id, node in nodes.items():
            if not node_id.startswith("model."):
                continue

            model_name = node.get("name")
            if not model_name:
                continue

            registry[model_name] = {
                "project": extract_project_from_node(node_id),
                "schema": node.get("schema"),
                "database": node.get("database"),
                "fqn": ".".join(node.get("fqn", [])),
                "raw_code": node.get("raw_code", "") or "",
            }

    return registry


# -----------------------------------------------------------
# 4. Extract dependencies (ref(), source(), direct SQL access)
# -----------------------------------------------------------
REF_PATTERN = re.compile(r"ref\(['\"]([^'\"]+)['\"]\)")
SRC_PATTERN = re.compile(r"source\(['\"]([^'\"]+)['\"],\s*['\"]([^'\"]+)['\"]\)")
DIRECT_TABLE_PATTERN = re.compile(
    r"[A-Za-z0-9_]+\.common_data\.[A-Za-z0-9_]+"
)


def extract_dependencies_for_node(model_name, project, raw_code, registry):
    dependencies = []

    # 4A â€” ref('model')
    for m in REF_PATTERN.findall(raw_code):
        if m in registry:
            dependencies.append((
                m, registry[m]["project"], "ref"
            ))

    # 4B â€” source('schema','table')
    for schema, table in SRC_PATTERN.findall(raw_code):
        # treat table name as model if exists
        if table in registry:
            dependencies.append((
                table, registry[table]["project"], "source"
            ))

    # 4C â€” direct cross-project usage: cosmos_nonhcd_iceberg.common_data.table
    for m in DIRECT_TABLE_PATTERN.findall(raw_code):
        table = m.split(".")[-1]
        if table in registry:
            dependencies.append((
                table, registry[table]["project"], "direct"
            ))

    return dependencies


# -----------------------------------------------------------
# 5. Verify lineage extraction correctness
# -----------------------------------------------------------
def verify_lineage(manifests):
    registry = build_global_model_registry(manifests)
    print(f"\nğŸ” Loaded {len(registry)} total models.")

    missing_edges = []
    summary = defaultdict(list)

    for model, info in registry.items():
        deps = extract_dependencies_for_node(
            model, info["project"], info["raw_code"], registry
        )

        for dep, dep_project, relation in deps:
            summary[(info["project"], model)].append((dep, dep_project, relation))

            # If dependency SHOULD exist but was missed
            # (will later compare with your DB lineage table)
            if dep not in registry:
                missing_edges.append((model, dep, relation))

    # Print summary
    print("\n================ LINEAGE SUMMARY ================\n")
    for (proj, model), lst in summary.items():
        print(f"ğŸ“Œ {proj}.{model} depends on:")
        for d, p, r in lst:
            print(f"   â†’ {p}.{d}   [{r}]")
        print()

    # Missing edges
    print("\n================ POSSIBLE MISSING DEPENDENCIES ================\n")
    if not missing_edges:
        print("ğŸ‰ No missing dependencies found. Extraction is structurally correct.")
    else:
        for m, dep, r in missing_edges:
            print(f"âš  {m} depends on missing model {dep} via {r}")

    print("\n=====================================================\n")


if __name__ == "__main__":
    manifests = load_manifests()
    verify_lineage(manifests)
